"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.its = exports.parseSchema = void 0;
const parseAnyOf_1 = require("./parseAnyOf");
const parseBoolean_1 = require("./parseBoolean");
const parseDefault_1 = require("./parseDefault");
const parseMultipleType_1 = require("./parseMultipleType");
const parseNot_1 = require("./parseNot");
const parseNull_1 = require("./parseNull");
const parseAllOf_1 = require("./parseAllOf");
const parseArray_1 = require("./parseArray");
const parseConst_1 = require("./parseConst");
const parseEnum_1 = require("./parseEnum");
const parseIfThenElse_1 = require("./parseIfThenElse");
const parseNumber_1 = require("./parseNumber");
const parseObject_1 = require("./parseObject");
const parseString_1 = require("./parseString");
const parseOneOf_1 = require("./parseOneOf");
const parseNullable_1 = require("./parseNullable");
const parseSchema = (schema, refs = { seen: new Map(), path: [] }) => {
  if (typeof schema !== "object") return schema ? "z.any()" : "z.never()";
  if (refs.overrideParser) {
    const custom = refs.overrideParser(schema, refs);
    if (typeof custom === "string") {
      return custom;
    }
  }
  let seen = refs.seen.get(schema);
  if (seen) {
    if (seen.r !== undefined) {
      return seen.r;
    }
    if (refs.recursionDepth === undefined || seen.n >= refs.recursionDepth) {
      return "z.any()";
    }
    seen.n += 1;
  } else {
    seen = { r: undefined, n: 0 };
    refs.seen.set(schema, seen);
  }
  let parsed = selectParser(schema, refs);
  parsed = addMeta(schema, parsed);
  if (!refs.withoutDefaults) {
    parsed = addDefaults(schema, parsed);
  }
  seen.r = parsed;
  return parsed;
};
exports.parseSchema = parseSchema;
const addMeta = (schema, parsed) => {
  if (schema.description) {
    parsed += `.describe(${JSON.stringify(schema.description)})`;
  }
  return parsed;
};
const addDefaults = (schema, parsed) => {
  if (schema.default !== undefined) {
    parsed += `.default(${JSON.stringify(schema.default)})`;
  }
  return parsed;
};
const selectParser = (schema, refs) => {
  if (exports.its.a.nullable(schema)) {
    return (0, parseNullable_1.parseNullable)(schema, refs);
  } else if (exports.its.an.object(schema)) {
    return (0, parseObject_1.parseObject)(schema, refs);
  } else if (exports.its.an.array(schema)) {
    return (0, parseArray_1.parseArray)(schema, refs);
  } else if (exports.its.an.anyOf(schema)) {
    return (0, parseAnyOf_1.parseAnyOf)(schema, refs);
  } else if (exports.its.an.allOf(schema)) {
    return (0, parseAllOf_1.parseAllOf)(schema, refs);
  } else if (exports.its.a.oneOf(schema)) {
    return (0, parseOneOf_1.parseOneOf)(schema, refs);
  } else if (exports.its.a.not(schema)) {
    return (0, parseNot_1.parseNot)(schema, refs);
  } else if (exports.its.an.enum(schema)) {
    return (0, parseEnum_1.parseEnum)(schema); //<-- needs to come before primitives
  } else if (exports.its.a.const(schema)) {
    return (0, parseConst_1.parseConst)(schema);
  } else if (exports.its.a.multipleType(schema)) {
    return (0, parseMultipleType_1.parseMultipleType)(schema, refs);
  } else if (exports.its.a.primitive(schema, "string")) {
    return (0, parseString_1.parseString)(schema);
  } else if (
    exports.its.a.primitive(schema, "number") ||
    exports.its.a.primitive(schema, "integer")
  ) {
    return (0, parseNumber_1.parseNumber)(schema);
  } else if (exports.its.a.primitive(schema, "boolean")) {
    return (0, parseBoolean_1.parseBoolean)(schema);
  } else if (exports.its.a.primitive(schema, "null")) {
    return (0, parseNull_1.parseNull)(schema);
  } else if (exports.its.a.conditional(schema)) {
    return (0, parseIfThenElse_1.parseIfThenElse)(schema, refs);
  } else {
    return (0, parseDefault_1.parseDefault)(schema);
  }
};
exports.its = {
  an: {
    object: (x) => x.type === "object",
    array: (x) => x.type === "array",
    anyOf: (x) => x.anyOf !== undefined,
    allOf: (x) => x.allOf !== undefined,
    enum: (x) => x.enum !== undefined,
  },
  a: {
    nullable: (x) => x.nullable === true,
    multipleType: (x) => Array.isArray(x.type),
    not: (x) => x.not !== undefined,
    const: (x) => x.const !== undefined,
    primitive: (x, p) => x.type === p,
    conditional: (x) =>
      Boolean(
        "if" in x && x.if && "then" in x && "else" in x && x.then && x.else
      ),
    oneOf: (x) => x.oneOf !== undefined,
  },
};
